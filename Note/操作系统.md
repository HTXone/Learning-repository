# 操作系统(OS)

​		操作系统为系统软件 是管理 软硬件资源、数据 的计算机程序，控制其他程序运行并为用户提供交互界面 的软件集合

​		是对系统资源进行管理和分配，提高运行效率的作用 合理对各类作业进行调度 方便用户使用的程序集合

​		是硬件（裸机）之上的其他软件之下的第一层（最底层）软件 是其他软件的共同环境

​		OS的4点目标：

1. 方便性(用户观点)

   操作系统最终是要为用户服务的。提供良好的、一致的用户接口,弥补硬件系统的类型和数量差别,使计算机更容易使用。

2. 有效性(系统管理人员观点)

   使CPU、I/O设备和存储空间得到有效利用；管理和分配硬件、软件资源，合理地组织计算机的工作流程。提高系统资源利用率（主要原因，首要目的）提高系统吞吐量

3. 可扩充性

   OS应采用层次化结构,以便于增加新的功能层次和模块,并能修改老的功能层次和模块。

4. 开放性

   遵循标准规范,方便地实现互连,实现应用程序的可移植性和互操作性。

OS的作用: 是用户与计算机硬件之间的软件接口，资源管理者，扩充机器

1.接口控制方式：

1. 命令方式：联机方式与脱机方式
2. 系统调用方式
3. 图形、窗口方式

2.OS需要为计算机系统资源进行管理

1. 处理及管理
2. 存储器管理
3. I/O设备管理
4. 文件管理

3.OS为扩展机/虚拟机 （将覆盖了软件的机器为 扩充机器 或 虚拟机）

操作系统定非形式化义：系统软件 程序模块集合 资源管理 用户接口

推动操作系统发展的主要动力：

1. 不断提高计算机资源利用率

2. 方便用户

3. 器件的不断更新换代

4. 计算机体系结构不断发展

   

### 批处理系统 

批处理技术：计算机系统对一批作业自动进行处理

在批处理系统的软件控制下 计算机能自动成批处理一个或多个用户的作业（重点为中断处理）

中断：为多道程序并发执行打下基础

#### 单道批处理系统特征（操作系统的前身）

1. 自动性
2. 顺序新
3. 单道性

#### 多道批处理系统特征（已属于操作系统的一种）

1. 多道性
2. 无序性：完成顺序无序
3. 调度性：作业调度与进程调度
4. 宏观上并发（同时执行了程序）微观上串行（CPU只能被一个程序进行利用）



#### 分时系统：

​		指在一台计算机上连接了多个带有显示器和键盘的终端 同时允许多个用户共享主机中的资源（CPU时间） 每个用户都可通过自己的中端以交互方式来使用计算机

需求：人机交互，共享主机，便于用户使用。

把计算机的系统资源(尤其是CPU时间)进行时间上的分割,每个时间段称为一个时间片(time slice),每个用户依次轮流使用时间片

“分时”的含义是指多个用户分享使用同一台计算机;多个程序分时共享硬件和软件资源;满足用户需要。

​		多个用户分时:单个用户使用计算机的效率低,因而允许多个应用程序同时在内存中,分别服务于不同的用户。有用户输入时由CPU执行,处理完一次用户输入后程序暂停,等待下一次用户输入－－时走时停 

前台和后台程序(foreground & background)分时:后台程序不占用终端输入输出,不与用户交互－－现在的图形用户界面(GUI),除当前交互的程序(输入焦点)之外,其他程序均作为后台。

通常按时间片(time slice)分配:各个程序在CPU上执行的轮换时间

​		强调要求：即使有多个用户同时通过自己的键盘键入命令,系统也应能全部地及时接收并及时处理。

关键问题：及时接收（配置多路卡）及时处理（在不长的时间内能响应用户命令）

实现方法：

1. 单道分时
2. 具有前台（单道分时）和后台（单道批处理）
3. 多道分时

特征：

1. 多路 宏观上多个用户同时工作,微观上多个终端轮转时间片
2. 独立 每个用户一台终端,互不干扰,感觉像一个人独占计算机
3. 及时 用户请求应尽快得到响应(2-3秒)
4. 交互 用户可通过终端与系统进行广泛的人机对话



#### 实时系统：

​		系统能及时或即时响应外部事件的请求 在规定时间内完成对该事件的处理 并控制所有实时任务协调一致地运行

要求：响应时间短,在一定范围之内;系统可靠性高

需求：实时控制，实时信息处理。

实时任务： 

1. 按任务周期性划分 周期性与非周期性
2. 按截止时间划分：开始截止时间，完成截止时间
3. 截止时间要求：
   1. 硬实时任务：系统必须满足任务对截止时间的要求,否则可能出现难以预测的结果。
   2. 软实时任务：若偶尔错过了任务的截止时间,对系统产生的影响也不会太大。

实时系统与分时系统特征的比较

(1)多路性

 实时系统:表现为对多个对象的信息采集和控制。

 分时系统:为多个终端服务。

(2)独立性

 实时系统:表现为对多个对象的互不干扰(分别为温度、压力采集)。

 分时系统:每个用户独占主机。

(3)及时性

 实时系统:在规定的时间内对外部事件响应。

 分时系统:在一定时间处理各个终端用户作业。

(4)交互性

 实时系统:一般情况下无交互性。

 分时系统:由交互引入。

(5)可靠性

 实时系统:要求高度可靠。分时系统:可靠性低。



#### 网络操作系统：

​		计算任务由大量独立而又相互联结的计算机共同完成。某一台计算机上的用户可以使用其它计算机上的资源。这就形成了计算机网络技术。 

​		网络操作系统是在操作系统之上增加网络功能实现的。网络功能部分模块将网络中的各台计算设备通过各种网络协议,实现各台计算设备之间的通信及网络中各种资源的共享

​		类型：

​		按拓扑结构分类：星型、树型、总线型、环型、网状型。

​		按网络地理范围分类：广域网，局域网。

​	网络操作系统模式：客户端/服务端模式，对等模式

​	功能：网络通信，网络资源管理，网络服务，网络管理，互操作能力。

#### 分布式操作系统：

**由多个分散的处理单元经互联网络的连接而形成的系统。**拥有极高的运算能力和数据共享特性

特征：

(1)分布性

 分布式OS:控制是分布式的,均匀分布在各处理单元(站点)上。

 网络OS:控制是集中式的,在某个主机或服务器中。

(2)并行性

 分布式OS:分配多个任务到多个处理器上并行执行。

 网络OS:无任务分配功能,因为任务都在本地机上处理。

(3)透明性

 分布式OS:具有物理位置上的透明性。

 网络OS:具有操作实现上的透明性。

(4)共享性

 分布式OS:共享各站点资源。

 网络OS:共享主机服务器资源。

(5)健壮性

 分布式OS:任何站点的故障,不影响整个系统。

 网络OS:集中控制(服务器),具有潜在的不可靠性。

## 操作系统基本特征：

1. 并发：即宏观上在一段时间内有多道程序在同时运行,在微观上,这些程序在交替执行的。为使程序能并发执行,为每个程序建立进程。进程是能独立运行并作为资源分配的基本单位,是活动实体。
2. 共享：系统中的资源可供内存中多个并发执行的进程(线程)共同使用由于资源属性的不同,进程对资源共享的方式也不同,目前主要有以下两种资源共享方式。
3. 虚拟：是指通过某种技术把一个物理实体变为若干个逻辑上的对应物。物理实体(前者)是实的, 即实际存在的;而后是虚的,是用户感觉上的东西。相应地,用于实现虚拟的技术,称为虚拟技术
4. 异步：在多道程序环境下,允许多个进程并发执行,但只有进程在获得所需的资源后方能执行

#### 并发：即宏观上在一段时间内有多道程序在同时运行,在微观上,这些程序是在交替执行的。（并发时在一段时间间隔内有多个事件发生但同一时刻只有一个事件发生，并行是指在同一时刻有多个事件发生）

CPU外设并行工作

进程是能独立运行并作为资源分配的基本单位,是活动实体。

线程是独立运行的基本单位 进程是分配资源的基本单位

#### 共享是指系统中的资源可供内存中多个并发执行的进程(线程)共同使用。

互斥共享 同一时间只能有一个进程访问

同时访问 同一时间可有多个进程访问

#### 并发和共享是操作系统的两个最基本的特征,它们又是互为存在的条件

​		一方面,资源共享是以程序(进程)的并发执行为条件的,若系统不允许程序并发执行,自然不存在资源共享问题;另一方面,若系统不能对资源共享实施有效管理, 协调好诸进程对共享资源的访问,也必然影响到程序并发执行的程度,甚至根本无法并发执行。

#### 虚拟 是指通过某种技术把一个物理实体变为若干个逻辑上的对应物

#### 进程是以人们不可预知的速度向前推进,此即进程的异步性。（即一个进程可能因为资源的调度导致在运行期间存在挂起状态）

## 进程管理：

进程管理的主要功能是把处理机分配给进程,并对处理器运行进行有效地控制和管理,以及协调各个进程之间的相互关系

#### 前驱图：即数据结构中的前驱图（关键路径问题）

前趋图是一个有向无循环图,记为DAG(Directed Acyclic Graph),用于描述进程之间执行的前后关系。图中的每个结点可用于描述一个程序段或进程,乃至一条语句;结点间的有向边则用于表示两个结点之间存在的偏序(Partial Order)或前趋关系(Precedence Relation)“→”

程序执行：顺序执行（单道批处理与简单单片机）与并发执行（提高资源利用率）

顺序执行特征：

1. 顺序性：处理机的操作严格按照程序所规定的顺序执行,只有当上一个操作完成后,下一个操作才能执行。
2. 封闭性：程序运行在一个封闭的环境中,即程序运行时独占系统的全部资源,这些资源的状态只能因程序的执行而改变,不受任何外界因素的影响。
3. 可再现性：由于程序顺序执行的封闭性,只要程序顺序执行的初始条件和环境相同,则不论何时执行,也不论程序执行期间是否存在停顿,程序所得的结果也相同。

并发执行特征：

1. 间断性：一个程序可能走到中途停下来,失去原有的时序关系;
2. 失去封闭性：程序并发执行时,系统中多道程序共享资源,资源的状态不是唯一地取决于某一个程序,因此,必然失去了程序的封闭性,而程序的执行结果因依赖于外部环境也失去了可再现性。
3. 不可再现性：失去封闭性－>失去可再现性;外界环境在程序的两次执行期间发生变化,失去原有的可重复特征。

（需要能对并发执行实例画出前驱图）

对并发程序的可再现性存在公式：波恩斯坦的并发执行可再现性条件

(R(P1)∩W(P2))∪(R(P2)∩W(P1))∪(W(P1)∩W(P2))=Ø

解释:

运算的读集R(Pi)是指在运算执行期间参考的所有变量的集合;

运算的写集W(Pi)是指在运算执行期间要改变的所有变量的集合。



#### 进程实体：

#### 三部分：

1. 程序段：**进程要进行的操作。**
2. 数据段：**包括操作的数据和程序自己的变量。**
3. 进程控制块（进程存在唯一标志）（Process Control Block /PCB）：**存放进程标识符、进程运行的当前状态、程序和数据的地址、程序运行时的CPU环境等**。

#### 进程的特征：

1. 动态性:进程是一个动态的概念,实质上是程序的一次执行过程。进程具有生命期:它因“创建”而产生,因“调度”而执行,执行时还走走停停,因“撤消”而灭亡。

2. 并发性:多个进程实体同存于内存中,且能在一段时间内同时运行,共享系统资源;引入进程实体的目的就是并发执行;

3. 独立性:进程是一个能独立运行的基本单位,也是系统进行资源分配和调度的基本单位;

4. 异步性:各进程按各自独立的、不可预知的速度向前推进;

5. 结构特征:程序段、数据段和PCB;程序文件中通常也划分了代码段和数据段,进程的创建与撤消就是PCB的创建与撤消。

#### 进程的定义：**进程是进程实体的运行过程**,**是系统进行资源分配和调度的一个独立单位**

(1)进程是程序的一次执行。

(2)进程是一个程序及其数据在处理机上顺序执行时所发生的活动。

(3)进程是程序在一个数据集合上运行的过程,它是系统进行资源分配和调度的一个独立单位。

进程与程序的区别：

Ø进程是动态的,程序是静态的:程序是有序代码的集合,它可以复制;进程是程序在数据集上的一次执行。

Ø进程是暂时的,程序是永久的:进程是一个状态变化的过程,有它的撤销,程序可长久保存。

Ø进程具有结构特征,由程序段、数据段和进程控制块三者组成,而程序仅是指令的有序集合,是进程的组成部分之一。

Ø进程与程序的对应关系:通过多次执行,一个程序可对应多个进程;

#### 进程三种基本状态：（到阻塞态时会释放处理机资源 所以阻塞态的下一步是就绪态）

(1)就绪(Ready)状态

进程已获得除处理机外的所需资源,等待分配处理机资源;只要分配CPU就可执行。

一个系统中多个处于就绪状态的进程排成就绪队列。

(2)执行(Running)状态

处于就绪状态的进程一旦获得了处理机,就可以运行,进程状态也就处于执行状态。

处于此状态的进程的数目小于等于CPU的数目。

(3)阻塞(Blocked)状态(“等待”或“睡眠”)

由于进程等待某种事件(如I/O操作或进程同步),在事件发生之前无法继续执行。该事件发生前即使把处理机分配给该进程,也无法运行。如:请求I/O操作,申请缓冲空间等

通常阻塞进程也排成若干队列。

系统调用创建或终止进程

![](D:\操作系统\QQ截图20200316114105.png)

Ø新**(创建)状态**

   当一个新进程刚刚建立**,还未将其放入就绪队列时的状态,称为新状态。**

Ø终止状态

   当一个进程已经**正常结束或异常结束,操作系统已将其从系统队列中移出,但尚未撤消,这时称为终止状态。**

![](D:\操作系统\QQ截图20200316114452.png)

挂起状态：在进程执行过程中未发生其他操作但将进程暂停静止的状态

#### 引入挂起状态的原因 

(1)终端用户的请求

 当终端用户在自己的程序运行期间发现有可疑问题时,希望暂时将自己的程序静止下来。

(2)父进程请求

 父进程需要考查和修改子进程。

(3)操作系统的需要

 如检查运行中的资源使用情况。

(4)对换的需要

 缓和内存紧张,将阻塞进程换到外存上,有别于阻塞状态。

(5)负荷调节的需要

 在实时系统中为了调整工作负荷可将不重要的进程挂起。

![](D:\操作系统\QQ截图20200316115045.png)

PCB 使一个在多道程序环境下不能独立运行的程序(含数据),成为一个能独立运行的基本单位,一个能与其它进程并发执行的进程，其记录了操作系统所需的**,用于描述进程情况及控制进程运行所需的全部信息**

OS**是根据PCB来对并发执行的进程进行控制和管理的。**

#### PCB是进程存在的唯一标志

### PCB中信息：

1. 进程标识符 唯一标识进程（内部标识符：系统自己使用，外部标识符：由用户（进程）访问时使用）

2. 处理机状态：由处理及中各种寄存器内容组成
   1. 通用寄存器,又称为用户可视寄存器,它们是用户程序可以访问的,用于暂存信息,在大多数处理机中,有8~32 个通用寄存器,在RISC结构的计算机中可超过100个;
   2. 指令计数器PC,其中存放了要访问的下一条指令的地址;
   3. 程序状态字PSW,其中含有状态信息,如条件码、执行方式、中断屏蔽标志等;
   4. 用户栈指针,指每个用户进程都有一个或若干个与之相关的系统栈,用于存放过程和系统调用参数及调用地址。栈指针指向该栈的栈顶。
3. 进程调度信息：与进程调度与进程对换有关的信息
   1. 进程状态
   2. 进程优先级
   3. 进程调度其他信息
   4. 事件（阻塞原因）
4. 进程控制信息：
   1. 程序和数据地址：是指进程的程序和数据所在的内存或外存地(首)址,以便再调度到该进程执行时,能从PCB中找到其程序和数据;
   2. 进程同步和通信机制,指实现进程同步和进程通信时必需的机制, 如消息队列指针、信号量等,它们可能全部或部分地放在PCB中;
   3. 资源清单,是一张列出了除CPU以外的、进程所需的全部资源及已经分配到该进程的资源的清单;
   4. 链接指针,它给出了本进程(PCB)所在队列中的下一个进程的PCB的首地址

PCB组织方式：

1. 链接方式 把具有同一状态的PCB用其中的链接字链接成一个队列,可以形成就绪队列、若干个阻塞队列和空闲队列

   ![](D:\操作系统\QQ截图20200323105018.png)

2. 索引方式 系统根据所有进程的状态建立几张索引表,如就绪索引表、阻塞索引表等,并把各索引表在内存的首地址记录在专用单元中。索引表中记录的是PCB在PCB表中的首地址。

   ![](D:\操作系统\QQ截图20200323105110.png)

进程控制：**进程管理最基本功能**

1. 创建新进程
2. 终止已结束进程
3. 终止因异常无法进行的进程
4. 负责进程状态的转化

原语：由若干条指令构成的原子操作的过程 在执行期间不可中断 以保证正确性

系统调用不都是原语

进程图：用于描述一个进程的家族关系的有向树,树中的结点表示进程

子进程可以继承(Inherit)父进程的资源。



处理机的执行状态分系统态和用户态两种:

   (1)系统态(管态、核心态):有较高特权,能执行一切指令,访问所有寄存器和存储区。

   (2)用户态(目态):有较低特权,能执行规定指令,访问指定寄存器和存储区。



 用户程序运行在用户态,不能执行OS指令及区域。

 OS内核运行在系统态,进程控制是由OS内核实现的。



进程创建步骤：

1. 申请空白PCB

2. 为新进程分配资源

   Ø为新进程的程序和数据分配内存。对于批处理型作业,可以在用户提出创建进程时要求提供所需内存大小。对于交互型作业可以由系统来分配一定的空间

3. 初始化进程控制块

   Ø初始化标识信息将系统标识信息写入新PCB

   Ø初始化处理机状态信息使程序计数器指向程序的入口地址,栈指针指向栈顶

   Ø初始化处理机控制信息将进程的状态设为就绪状态或静止就绪状态

4. 将新进程插入就绪队列

创建原语：新建PCB并将有关参数记录进PCB中

进程终止（产生中断）原因：正常终止，异常终止，外界干预

终止过程：

1. 根据被终止进程的标识符,从PCB集合中检索出该进程的PCB,从中读出该进程的状态。
2. 若被终止进程正处于执行状态,应立即终止该进程的执行,并置调度标志为真,用于指示该进程被终止后应重新进行调度。
3. 若该进程还有子孙进程,还应将其所有子孙进程予以终止,以防他们成为不可控的进程。
4. 将被终止进程所拥有的全部资源,或者归还给其父进程, 或者归还给系统。
5. 将被终止进程(它的PCB)从所在队列(或链表)中移出,等待其他程序来搜集信息。

进程阻塞事件：

1. 请求系统服务
2. 启动某操作
3. 新数据尚未到达
4. 无新工作可做

进程阻塞过程

Ø正在执行的进程,当发现上述某事件时,由于无法继续执行,于是进程便通过调用阻塞原语block()把自己阻塞。可见,进程的阻塞是**进程自身的一种主动行为**

Ø进入block过程后,由于此时该进程还处于执行状态,所以应先立即停止执行,把进程控制块中的现行状态由“执行”改为阻塞,并将PCB插入阻塞队列

Ø如果系统中设置了因不同事件而阻塞的多个阻塞队列,则应将本进程插入到具有相同事件的阻塞(等待)队列

Ø调度程序进行重新调度,将处理机分配给另一就绪进程,并进行切换,亦即,保留被阻塞进程的处理机状态(在PCB中),再按新进程的PCB中的处理机状态设置CPU的环境

进程唤醒：当阻塞进程所等待的事件发生时则该进程调用唤醒原语wakeup()并将该等待事件的进程唤醒

Ø**唤醒原语执行的过程是**

1. 把被阻塞的进程从等待该事件的阻塞队列中移出

2. 将其PCB中的现行状态由阻塞改为就绪

3. 将该PCB插入到就绪队列中



进程挂起：当出现了引起进程挂起的事件时,比如,用户进程请求将自己挂起,或父进程请求将自己的某个子进程挂起, 系统将利用挂起原语suspend( )将指定进程或处于阻塞状态的进程挂起。

suspend()原语的执行过程

ü首先检查被挂起进程的状态,若处于活动就绪状态,便将其改为静止就绪;对于活动阻塞状态的进程,则将之改为静止阻塞。
ü为了方便用户或父进程考查该进程的运行情况而把该进程的PCB复制到某指定的内存区域。
ü若被挂起的进程正在执行,则转向调度程序重新调度。

进程激活：当发生激活进程的事件时,例如,父进程或用户进程请求激活指定进程,若该进程驻留在外存而内存中已有足够的空间时,则可将在外存上处于静止就绪状态的进程换入内存。这时,系统将利用激活原语active( )将指定进程激活。

active()原语执行过程

ü激活原语先将进程从外存调入内存,检查该进程的现行状态,若是静止就绪,便将之改为活动就绪;若为静止阻塞便将之改为活动阻塞。
ü假如采用的是抢占调度策略,则每当有新进程进入就绪队列时,应检查是否要进行重新调度,即由调度程序将被激活进程与当前进程进行优先级的比较,如果被激活进程的优先级更低,就不必重新调度;否则,立即剥夺当前进程的运行,把处理机分配给刚被激活的进程。

## 进程同步：

进程制约：

制约关系：
在多道程序环境下,当程序并发执行时,由于资源共享和进程合作,使同处于系统中的诸进程之间存在两种形式的制约关系。

1. 间接互相制约关系
   同处于一个系统中的进程必然**共享**某种资源,如CPU、I/O设备等,间接相互制约即源于资源共享。如A、B共享打印机,若A申请打印时,打印机已分配给B,则A只能阻塞,等B释放后再改为就绪,又称为“互斥”
2. 直接相互制约关系
   这种制约源于进程之间的合作关系。如进程A向B提供数据,当输入缓冲空时,B不能得到数据而阻塞;反之当缓冲满时,A无法写入而阻塞,又称为“同步”。

临界资源：在一段时间内只允许一个进程访问的资源

临界区：每个进程中访问临界资源的代码为临界区

进入区：每个进程进入临界区之前应先对欲访问的临界资源进行检查,看是否正在被访问。如果此刻该临界资源未被访问,该进程可进入临界区,并设置它正在被访问的标志,在临界区之前执行的这段代码为进入区

退出区：在临界区后面也要加上一段代码,用于将临界区被访问的资源恢复为未被访问的标志,称为退出区

同步机制规则：

1. 空闲让进
   当无进程处于临界区时,应允许一个进程进入临界区,以有效利用临界资源。
2. 忙则等待
   当有进程进入临界区时,其他进程必须等待。
3. 有限等待
   对要求访问临界资源的进程,应保证在**有限时间**内进入自己的临界区,防止“死等”
4. 让权等待
   当进程不能进入其临界区时,应**立即释放处理机**,防止“忙等”,不能一直用语句判断能不能进,占用处理机。

#### 信号量机制：

**信号量只有P,V两种操作 不能对其进行其他操作 (如比较符等）**

先进行同步P操作，后执行互斥P操作
有时互斥操作可通过已执行同步操作来执行

Ø信号量机制已从整型信号量发展为记录型信号量、AND型信号量,又进一步发展为信号量集。

Ø目前,信号量机制已广泛应用于单处理机、多处理机以及计算机网络中。

Ø信号量就是**OS提供的管理公有资源**的有效手段。

Ø信号量代表**可用资源实体的数量**。

整型信号量：
通过一个记录数S（可分配资源）来进行记录 进入区当S>0时S-1当S<=0时空转 退出区时S+1； 

记录信号量：
加入让权等待机制 建立等待链表 P操作但无可分配资源时当前进程挂起 当V操作且等待队列不为空时 等待队列第一个进程唤醒

AND型信号量：
对需要多个资源的进程启用分配时同时一次分配所有所需资源 释放时一次释放所有占用资源 每次分配时查询是否可以资源分配 任何一种不可即不分配

信号量集：一次申请多个资源

一般“信号量集”的几种特殊情况:

  (1)SP(S, d, d)。此时在信号量集中只有一个信号量S, 但允许它每次申请d个资源,当现有资源数少于d时,不予分配。

  (2)SP(S, 1, 1)。此时的信号量集已蜕化为一般的记录型信号量(S＞1时)或互斥信号量(S=1时)。

  (3)SP(S, 1, 0)。这是一种很特殊且很有用的信号量操作。当S≥1时,允许多个进程进入某特定区;当S变为0后,将阻止任何进程进入特定区。换言之,它相当于一个可控开关。

信号量应用：

1. 实现进程的互斥（互斥信号量）（P V 操作必须成对出现 缺失P会导致系统混乱 缺失V会导致资源永久占用）

2. 实现前驱关系
   ![](D:\操作系统\QQ截图20200330120513.png)ac

   

## 经典进程同步问题：

生产消费，哲学家进餐，读写

### 生产消费问题：输入输出共享缓存区问题

输入存在缓存满问题 输出存在缓存空问题
设置两个信号量 full表示存入个数 empty表示空余个数
单个缓冲 full初始化0 empty初始化1

生产：<img src="D:\操作系统\QQ截图20200413101020.png" style="zoom:67%;" />	消费：<img src="D:\操作系统\QQ截图20200413101214.png" style="zoom:67%;" />

P/V成对出现但对变量不一定需要同样

多个生产消费者 ：

full初始化为0 empty初始化为n 同时需要一个互斥信号量mutex来对操作进行自锁保证只有一个进程访问缓冲区 初始化为1

用循环指针列表来模拟缓冲队列

生产：<img src="D:\操作系统\QQ截图20200413102257.png" style="zoom:67%;" />(其中in为生产者指针)

消费：<img src="D:\操作系统\QQ截图20200413102431.png" style="zoom:67%;" />(out为消费者指针）

（P之间可能存在延迟 导致可能为按顺序完成）

其中P（mutex）必须邻接生产消费操作（保证只有一个进程进行生产消费） 否则会发生死锁 （在mutex容许中 full或empty的死循 且因为mutex进入导致无法进行full/empty的值的改变） 但V操作可变化
优化为AND型 同时保证资源信号量在前 互斥信号量在后

mutex 生产消费间 防止消费和生产同时 导致消费生产极点错误
mutex 生产生产 消费消费 间 防止同时导致顺序错误或同读同写 

### 哲学家问题：对临界共享资源的同步问题

待解决问题 ：同时拿起一边筷子导致死锁

只允许n-1个人同时拿起筷子
<img src="D:\操作系统\QQ截图20200413105849.png" style="zoom:67%;" />

仅可同时拿起左右两边才可以进餐（And型信号量）

规定奇数号哲学家先拿左边 偶数先拿右边（保证奇偶间的竞争一放弃保证至少一可用）

### 读写问题：写间互斥 写与读间互斥 读间不需要互斥（文件读写情景）

设置两个信号量 一个用于读和写之间互斥和写与写之间互斥（wmutex）初值1  并设置一个正在读进程个数计数器readcount初值0 另一个信号量用于readcount改变互斥（rmutex）初值1

读操作 ：（注意rmutex和wmutex的P顺序）

```
P(rmutex);					//如果顺序颠倒 可能导致两个0读进入一个死锁直到另一个释放wmutex资源
if(readcount == 0) P(wmutex);
readcount++;
V(rmutex);
....
P(rmutex);
readcount--;
if(readcount == 0) V(wmutex);
V(rmutex);
```

写操作：

```
P(wmutex);
...
V(wmutex);
```

读写问题满足波恩斯坦公式（对文件）

### 同步与互斥问题求解：

![](D:\操作系统\QQ截图20200413114912.png)

## 管程机制：

优化当信号量机制中PV操作不当导致的死锁

管程定义：

一个管程定义了一个数据结构和能为并发进程所执行的一组操作 这组操作能同步进程和改变管程中的数据

构成三部分：

1. 局部域管程的**共享变量说明**
2. 对该数据结构进行**操作**的**一组过程**
3. 对局部于管程的数据**设置初始值**的**初始化语句**

管程也必须要有一个名字

<img src="D:\操作系统\QQ截图20200413120056.png" style="zoom:80%;" />

同步 设置原语 wait和 signal

例：

![](D:\操作系统\QQ截图20200413121229.png)

对外部只需要进行放入和拿取即可 等待队列由管程实现

## 进程通信：

定义：为协调完成某一任务,几个进程间应保持联系,交换一定数量的信息。

低级进程通信：仅交换少量的数据和一些状态。如:P、V操作。

高级进程通信：交换信息量大。用户可直接利用OS提供的通信命令高效地传送大量数据。

三大高级进程通信方式：共享存储器系统、消息传递系统和管道通信系统

共享存储器：
![](D:\操作系统\QQ截图20200415153508.png)

消息传递系统：
![](D:\操作系统\QQ截图20200415153657.png)

消息传递直接通信方式：发送进程直接将消息发送给接收进程,并将消息挂在接收进程的消息队列上。接收进程从消息队列中取得消息。要求发送进程和接收进程都以显式方式提供对方的标识符
原语：Send(Receiver,message),Receive(Sender,message) 未接收到则等待直到存在消息发过来

消息传递间接通信方式：发送进程发送消息到“信箱”中,接收进程从“信箱”中取得消息,相应系统称为电子邮件系统。
信箱创建和撤销：创建时给出信箱名字，信箱属性（公用，私用，共享）（对于共享邮箱还需要给出共享者的名字） 不需要时使用撤销原语进行撤销
发送接收原语：Send(mailbox,message),Receive(mailbox,message) 发送信息到指定邮箱和从指定邮箱中接收到一个信息
私有邮箱：用户进程建立 信箱拥有者从信箱中读取消息 其他用户只能将消息发送到该邮箱中 邮箱随进程结束而结束
公用信箱：由操作系统创建 核准进程既可把消息发送到该信箱中,也可从信箱中读取发送给自己的消息。
共享信箱：由某进程创建在创建时或创建后指明其为可共享的 同时指出共享进程名字 信箱拥有者和共享者都有权从信箱中**取走**发送给**自己**的消息。
信箱通信 存在 一对一 一对多 多对多 多对一

管道通信：

管道：是指用于连接一个读进程和一个写进程以实现他们之间通信的一个共享文件,又名pipe文件（即位linux里的管道操作）

以文件为介质 字符流读写 队列方式工作

向管道(共享文件)提供输入的发送进程(即写进程),以字符流形式将大量的数据送入管道;而接受管道输出的接收进程(即读进程),则从管道中接收(读)数据

管道机制 三方面协调能力：

1. 互斥：即当一个进程正在对pipe执行读/写操作时,其它(另一)进程必须等待
2. 同步：指当写(输入)进程把一定数量(如4KB)的数据写入pipe,便去睡眠等待,直到读(输出)进程取走数据后,再把他唤醒。当读进程读一空pipe时,也应睡眠等待,直至写进程将数据写入管道后,才将之唤醒
3. 确定对方存在

消息缓冲区：消息缓冲队列通信方式中主要利用的数据结构
描述：<img src="D:\操作系统\QQ截图20200415190131.png" style="zoom:67%;" />
PCB中有关通信的数据项。在利用消息缓冲队列通信机制时,在设置消息缓冲队列的同时,还应增加用于对消息队列进行操作和实现同步的信号量,并将它们置入进程的PCB中。在PCB中应增加的数据项可描述如下:
<img src="D:\操作系统\QQ截图20200415190642.png" style="zoom:50%;" />

**发送原语**
发送进程在利用发送原语发送消息之前,应先在自己的内存空间,设置一发送区a,把待发送的消息正文、发送进程标识符、消息长度等信息填入其中,然后调用发送原语,把消息发送给目标(接收)进程
发送原语首先根据发送区a中所设置的消息长度a.size来申请一缓冲区i,接着,把发送区a中的信息复制到缓冲区i中
为了能将i挂在接收进程的消息队列mq上,应先获得接收进程的内部标识符j,然后将i挂在j.mq上
由于该队列属于临界资源,故在执行insert操作的前后,都要执行wait和signal操作

## 线程：

引入进程为了实现程序并发 改善系统资源利用率 提高系统处理吞吐量
进程自己拥有资源
进程可独立调度分配基本单位

线程引入为进程减少切换的时间空间开销

进程为资源分配独立单位

**线程作为可独立调度的执行单位 不拥有或拥有极少资源**

线程是进程的一个组成部分 进程包含多个线程
进程多个线程在进程地址空间内活动
资源分配对象是进程（管理）
调度的基本单位是线程（运行）
在不同进程的线程间的同步用消息通信办法。通信是线程,用的消息队列是进程的资源。

## 处理机调度：

主要任务是分配处理机 

高级 中级 低级调度

#### 高级调度：作业调度 长程调度 接纳调度

将外存上处于后备队列上的作业调入内存 并创建进程 分配资源 安排在**就绪队列**上

调度考虑问题：

1. 接纳多少作业 由多道程序度决定（允许多少个作业同步执行）少：浪费资源 多：影响性能
2. 接纳哪些作业 作业调度算法决定

#### 低级调度：进程调度 短程调度

决定**就绪队列**中的哪几个进程应当获得处理机

1. 非抢占方式 一旦将处理机分配道某进程 便让该进程一直执行 直到该进程完成或堵塞时再分配给其他
   优点：简单 系统开销小
   缺点：不能用于实时系统的实时事件处理
2. 抢占方式 允许调度程序根据某种原则暂停执行
   优点：保证系统实时性
   缺点：增加进程调度次数  增加开销

#### 中级调度：中程调度

为了实现对换 提高内存利用率和系统吞吐量 让暂时**不运行进程**调到**外存**此时进程为**挂起态**当运行时再调入内存此时进程为就绪态

## 调度队列模型：

分时系统简单调度队列模型：
<img src="D:\操作系统\QQ截图20200415191711.png" style="zoom:50%;" />
高低两级调度调度队列模型：
<img src="D:\操作系统\QQ截图20200415191853.png" style="zoom:50%;" />
三级调度调度队列模型：
<img src="D:\操作系统\QQ截图20200415192331.png" style="zoom:50%;" />

具有高级和低级调度队列模型 在批处理系统中 不仅要有进程调度 还要有作业调度
存在多道阻塞队列 后备队列

具有中级调度队列模型
存在阻塞挂起 就绪挂起队列

**周转时间：完成时间-到达时间**

**带权周转时间：周转时间/服务时间**

**等待时间（内存限定时存在）：开始执行时间-进入磁盘时间**（一般情况）
**等待时间：周转时间-运行（服务）时间  （时间片轮转）**

调度算法比较：平均周转时间 和 平均带权周转时间

**响应时间是指从用户通过键盘提交一个请求开始,直至系统中首次产生响应为止的时间。**
响应时间包括键盘输入请求信息传送到处理机的时间、处理机对请求的处理时间和响应信息送回到终端的时间

截止时间是指某任务必须开始执行的最迟时  间或必须完成的最迟时间
截止时间是实时系统中的重要指标

选择调度方式和调度算法的准则：

1. 面向用户准则：
   1. 周转时间短
   2. 响应时间快
   3. 截止时间保证
   4. 优先权准则
2. 面向系统准则
   1. 系统吞吐量高（吞吐量指单位时间内系统所完成的作业数 作业调度的方式和算法对吞吐量的大小有较大影响）
   2. 处理机利用率高
   3. 各类资源平衡利用（使内存、外存和I/O设备的利用率高）

#### 调度算法：

在OS中调度的实质是一种资源分配,因而调度算法是指:根据系统的资源分配策略所规定的资源分配算法

对不同的系统和系统目标,通常采用不同的算法,如短作业优先,时间片轮转等

有些算法适用于作业调度（高级调度）,有些适用于进程调度（低级调度）,有些两者皆可

#### FCFS 先来先服务调度算法：

按照作业进入系统的先后次序进行调度,先进入系统者先调度;即启动等待时间最长的作业
是一种最简单的调度算法,即可用于**作业调度**,也可用于**进程调度**
FCFS算法比较**有利于长作业(进程)**,而不利于短作业(进程)

#### SJ(P)F 短作业(进程)优先调度算法：

短作业(进程)优先调度算法SJ(P)F,以要求运行时间长短进行调度,即启动要求运行时间最短的作业
可以分别用于作业调度和进程调度
短作业优先(SJF)的调度算法,是从**后备队列**中选择一个或若干个估计**运行时间最短**的**作业**,将 它们**调入内存**运行;而短进程优先(SPF)调度算法,则是从**就绪队列中**选出一估计**运行时间最短**的进程,将处理机分配给它,使它**立即执行并一直执行**到完成,或发生某事件而被阻塞放弃处理机时,再重新调度
优点：有效降低作业的平均等待时间，提高系统吞吐量。
缺点：对长作业不利，完全未考虑作业的紧迫程度，作业只由用户提供的估计执行时间而定 因为实时执行时间不确定导致并不能真正做到短作业优先

#### 非抢占式优先权算法：

系统一旦把处理机分配给就绪队列中**优先权最高**的进程后,该进程便**一直执行下去,直至完成**;或因发生某事件使**该进程放弃处理机时**,系统方可再将处理机重新分配给另一优先权最高的进程
主要用于**批处理系统**中,也可用于某些对**实时性要求不严**的实时系统中。

#### 抢占式优先权算法：

系统同样是把处理机分配给优先权最高的进程,使之执行。但在其执行期间,只要**又出现了另一个其优先权更高的进程**,进程调度程序就**立即停止当前进程**(原优先权最高的进程)的执行,**重新将处理机分配给新到的优先权最高的进程**。
抢占式的优先权调度算法,能更好地满足**紧迫作业**的要求,故而常用于**要求比较严格**的实时系统中, 以及对**性能要求较高**的批处理和分时系统中。

优先权决定依据：

1. 进程类型：  **系统进程**优先级**高于**用户进程
2. 进程对资源按要求：执行时间**短**,内存要求**小**的进程,有较**高优先权**
3. 用户要求：根据用户进程紧迫程度及用户所付费用的多少来确定。

优先权类别：

1. 静态优先权：静态优先权是在**创建进程**时确定的,且在进程的**整个运行期间保持不变**。一般地,优先权是利用某一范围内的一个整数来表示的
2. 动态优先权：在创建进程时所赋予的优先权,是可以**随进程的推进或随其等待时间的增加而改变的**,以便获得更好的调度性能。

（动态优先权变化：例如,我们可以规定,在就绪队列中的进程,**随其等待时间的增长,其优先权以速率a提高**。
若所有的进程都具有相同的优先权初值,则显然是最先进入就绪队列的进程,将因其动态优先权变得最高而优先获得处理机,此即**先来先服务FCFS算法**。
若所有的就绪进程具有各不相同的优先权初值,那么,对于优先权初值低的进程,在**等待了足够的时间后,其优先权便可能升为最高**,从而可以获得处理机）

#### 高优先权调度算法（HRF）：

结合FCFS SJF 算法 克服两算法的缺点
响应比最高的作业优先启动：![](D:\操作系统\QQ截图20200420104710.png)

![](D:\操作系统\QQ截图20200420104907.png)
(优先权=响应比R~p~)

算法解释：

1. 如果作业的等待时间相同,则要求服务的时间愈短,其优先权愈高,因而该算法有利于短作业（SJF）。
2. 当要求服务的时间相同时,作业的优先权决定于其等待时间,等待时间愈长,其优先权愈高,因而它实现的是先来先服务（FCFS）。
3. 对于长作业,作业的优先级可以随等待时间的增加而提高,当其等待时间足够长时,其优先级便可升到很高,从而也可获得处理机（抢占式调度）。

#### 时间片轮转调度：

系统将所有的**就绪进程按先来先服务**的原则,排成一个队列,每次调度时,把CPU分配给队首进程,并令其**执行一个时间片**,时间片的大小从几ms到几百ms
当**执行的时间片用完**时,由一个计时器发出**时钟中断请求**,调度程序便据此信号来**停止该进程的执行**,并将它**送往就绪队列的末尾**;然后,再把**处理机分配给就绪队列中新的队首进程,同时也让它执行一个时间片**
可以**保证就绪队列中的所有进程,在一给定的时间内,均能获得一时间片的处理机执行时间**

**（周转时间和带权周转时间仍然按最后完成时间-到达时间进行计算）**
（同一时刻新来进程排在队尾且在刚进行完进程之前）
（时间片内执行完CPU直接给下一进程）

#### 多级反馈队列调度：

![](D:\操作系统\QQ截图20200420110704.png)

优先权越低 时间片越长 运行时间越久
进程在第一队列得到时间片执行后 进程任务未执行完 进入第二队列队尾排队 重复下行 直到就绪队列n队尾 在队列n中循环等待时间片直到运行完毕
仅当i-1队列中空闲时 才执行第i队列 高优先度新进程由抢占式 抢夺当前正在处理队列时间片 且正在执行进程回到同层队列队尾等待 
（同时会根据新进程的优先级进行进程进入排队队列的选择 是优先度和时间片轮转的综合调度算法）

性能：![](D:\操作系统\QQ截图20200420111208.png)

FCFS进入有限主存和进入磁盘问题:

周转时间=执行结束时间-**进入磁盘**时间
但是FCFS是对**进入主存先后顺序先后执行**
因为容量有限 无法即使进入主存 可能后来进程要求主存短先进入先处理
![](D:\操作系统\QQ截图20200420114235.png)

有限内存 SJF调度计算同理


## 死锁产生原因与条件：

死锁：多个进程因竞争资源而造成的一种僵局，若无外力作用 此进程将不能再继续执行

可剥夺资源与非剥夺资源
可剥夺：获得资源后 仍然会被其他进程或系统剥夺
非剥夺：获得资源后 除非进程结束 否则无法再分配

竞争非剥夺性资源
系统中的非剥夺性资源由于数量有限而不能满足进程运行的需要,进程在运行过程中因争夺这些资源而限入僵局

竞争临时性资源
临时性资源区别于永久性资源,指由一个进程产生,被另一进程使用后就再也无用的资源,也称为消耗性资源

进程推进不当 导致死锁

**计算机同时具备4个必要条件发送死锁**

1. 互斥条件：进程对所分配到的资源进行排它性的使用。临界(独占)资源,

   即一次只有一个进程可以使用资源。

2. 请求和保持条件：进程已经至少保持了一个资源,但又提出了新的资源请求,而该资源又已被其他进程占有。

3. 不剥夺条件：进程已获得的资源在未使用完之前不能被剥夺。

4. 环路等待条件：在发生死锁时,必然存在一个进程--资源的环形链。

**只要一个必要条件不满足死锁就可排除**

处理死锁：

1. 预防：通过设置限制条件,破坏产生死锁的必要条件的一个或几个。
2. 避免：在分配资源时,用某种方法防止系统进入不安全的状态。
3. 检测：确定与死锁有关的进程和资源,采取措施,清除死锁。
4. 解除：与检测死锁配套的一种措施。

摒弃“请求和保持”条件 
所有进程在开始运行之前必须一次性的申请整个运行过程所需的全部资源。
优点:简单、易于实现、安全。
缺点:(1)资源浪费严重(2)进程延迟运行

摒弃“不剥夺”条件
系统规定:进程逐个地申请所需资源
当一个已经保持了某些资源的进程申请新资源而不能得到满足时,必须放弃所有已保持的资源
实现复杂、代价高昴(例如:打印机)

摒弃“环路等待”条件
系统将所有资源按类型分配序号并排队(例如打印机为1、磁带机为2、磁盘为3、等等)。
所有进程申请资源必须按序号递增的顺序
对比前两种方法:资源利用率和系统吞吐量较高
缺点:(1)序号固定,限制了新设备类型的增加(2)资源浪费(不像前边那么严重,考虑进程使用资源顺序了)(3)限制用户自由编程(因限制了序号)

系统安全状态：弱化限制 获得较好系统性能 当系统始终处于安全状态便可避免死锁

在避免死锁的方法中,允许进程**动态**地申请资源,但系统在进行资源分配之前,应**先计算此次资源分配的安全性**。若此次分配不会导致系统进入不安全状态,则将资源分配给进程; 否则,令进程等待。

  所谓安全状态,是指系统能按某种进程顺序(P1, P2, …,Pn)(称〈P1, P2, …, Pn〉序列为安全序列),来为每个进程Pi分配其所需资源,直至满足每个进程对资源的最大需求,使每个进程都可顺利地完成。如果系统无法找到这样一个安全序列,则称系统处于不安全状态。

### 银行家算法：

银行家算法的设计思想是:当用户申请一组资源时,系统必须做出判断;如果把这些资源分出去,系统是否还处于安全状态。若是,就可以分出这些资源;否则,该申请暂不予满足。

数据结构：

1. 可利用资源向量Available
   这是一个含有m个元素的数组,其中的每一个元素代表一类可利用的资源数目,其初始值是系统中所配置的该类全部可用资源的数目,其数值随该类资源的分配和回收而动态地改变。如果Available[j]=K,则表示系统中现有Rj类资源K个	

2. 最大需求矩阵Max
   这是一个n×m的矩阵,它定义了系统中n个进程中的每一个进程对m类资源的最大需求。如果Max[i,j]=K,则表示进程i需要Rj类资源的最大数目为K

3. 分配矩阵Allocation
   这也是一个n×m的矩阵,它定义了系统中每一类资源当前已分配给每一进程的资源数。如果Allocation[i,j]=K,则表示进程i当前已分得Rj类资源的数目为K

4. 需求矩阵Need这也是一个n×m的矩阵,用以表示每一个进程尚需的各类资源数。如果Need[i,j]=K,则表示进程i还需要Rj类资源K个,方能完成其任务

    Need[i,j]=Max[i,j]-Allocation[i,j]

使用步骤：

**先按安全性算法 算出当前的安全序列 当新的需求到达时 按照银行家算法 先和Need和Available比较看是否可分配 若可则重新调配2A 1N 并尝试重新构建安全序列 如果无法构建安全序列 则归回原状态不分配资源 否则分配资源并保持变化**

安全序列只是用于证明系统有能力保证多个进程的正常执行不会发生死锁 但资源的是否发放需要进程自己请求后并系统重新成功构建安全序列来判断

# 存储器管理

存储器管理的主要内容是内存
存储器是用来存放**系统和用户的程序和数据**,其特点是存取速度快,存储方式是以新换旧,断电信息丢失。

多道程序环境下 程序运行必须为创建进程 创建进程第一件事是分配内存

源程序需要编译 连接 装入等几个过程
编译：由编译程序对用户源程序进行编译 形成若干个目标模块
链接：由链接程序将编译后形成的一组目标模块以及它们多需要的库函数链接在一起 形成一个完整的装入模块
装入：由装入程序将装入模块装入内存
![](D:\操作系统\QQ截图20200427104912.png)

## 内存装入：

绝对装入：在编译时,如果知道程序将驻留在内存的什么位置,则编译程序产生绝对地址的目标代码 **按照绝对地址直接装入即可** 装入模块被装入内存后,由于程序中的逻辑地址与实际内存地址完全相同,故不需对程序和数据的地址进行修改
通常是宁可在程序中采用符号地址,然后在编译或汇编时,再将这些符号地址转换为绝对地址。
<img src="D:\操作系统\QQ截图20200427154057.png" style="zoom:50%;" />

可重定位装入（静态重定位）：模块建立 地址从0开始 其余地址相对0计算
在装入时对目标程序中指令和数据的修改过程称为重定位 同时地址变化在装入时**一次完成** 以后**不再发生变化**
<img src="D:\操作系统\QQ截图20200427154023.png" style="zoom:50%;" />

动态运行装入：将模块装入内存后 **不立即**将模块中的相对地址转换为绝对地址 把地址转换推迟到**程序真正要执行时才进行转换** 即装入内存后的模块内地址**仍然是相对地址** **依靠硬件支持进行地址转换** 同时这类定位方式使得**模块可以在内存中移动** 而非一旦装入不可改变地址

## 程序链接：

程序运行前 先将各目标模块以及所需库函数链接成一个完整的装入模块 

静态链接：程序运行前 先将目标模块和库函数完成链接且**以后不再拆开**
须解决问题：对相对地址的修改以及变换外部调用符号

装入时动态链接：将用户源程序编译后所得的一组目标模块在发生调用需要装入内存时采用**边装入边链接**
优点：便于目标模块的修改和更新，便于实现对目标模块的共享

运行时动态链接：运行时动态链接方式将对某些模块的链接推迟到执行时才去做,即在执行过程中,当发现一个被调用模块尚未装入内存时,立即由OS去找到该模块并将之装入内存,把它链接到调用者模块上
凡在执行过程中未被用到的目标模块,都不会被调入内存和被链接到装入模块上,这样不仅可加快程序的装入过程,而且可节省大量的内存空间

## 分区：

单一连续分配：将内存分为系统区和用户区两个部分 系统区仅给OS使用 用户区内存中**仅装有一道用户程序**
简单 系统开销小 资源利用率低

固定分区分配：将整个用户空间划分为若干个固定大小的区域 在每个分区中只装入一道作业 
建立分区使用表 按此表进行分配
分区方法 等分 不等分
<img src="D:\操作系统\QQ截图20200427162550.png" style="zoom:67%;" />

动态分区分配：根据进程的实际需要动态地分配内存空间

需要配置数据结构以描述空闲分区与已分配分区情况

1. 空闲分区表：用于记录每个空闲分区的情况
   <img src="D:\操作系统\QQ截图20200427163657.png" style="zoom:50%;" />
2. 空闲分区链 实现对空闲分区的分配和链接
   <img src="D:\操作系统\QQ截图20200427163744.png" style="zoom:67%;" />

同时使用分区分配算法：

1. 首次适应算法FF：
   	<img src="D:\操作系统\QQ截图20200427163851.png" style="zoom: 67%;" />
2. 循环首次适应算法NF：
   <img src="D:\操作系统\QQ截图20200427163940.png" style="zoom:67%;" />
   3. 最佳适应算法BF：
      每次分配内存时将能满足要求又是最小的空闲分区分配给作业
      该算法要求所有空闲分区按容量大小从小到大形成空闲分区链
      宏观上因为每次分割后的剩余部分最小 所以将产生许多碎片
      （内外碎片：
      内碎片：若干等分后固定分区内被进程占用后不能被其他进程利用的碎片
      外碎片：还未分配出去 但由于太小无法分配给申请内存的进程的空闲）
4. 最坏适应算法WF：
   选择一个最大的空闲区 分割后给作业使用
   同样建立空闲分区链但是是从大到小

<img src="D:\操作系统\QQ截图20200427164427.png" style="zoom:67%;" />

内存回收：进程运行完释放内存时,系统根据回收区的首地址,从空闲链表区找到相应的插入点,有以下几种情况
回收区与插入点的前一个空闲分区相邻接
回收区与插入点的后一个空闲分区相邻接 
回收区同时与插入点的前、后两个分区相邻接
回收区不与任何空闲区邻接
<img src="D:\操作系统\QQ截图20200427164535.png" style="zoom:67%;" />

<img src="D:\操作系统\QQ截图20200427164605.png" style="zoom:67%;" />

动态可重定位分区分配：
加入紧凑操作 将无法使用的碎片分区整合成一个打分区来使用 但同时 紧凑将增加主机开销以及修改空闲分区表

实现：作业装入内存后地址仍是相对地址 将相对地址转化为绝对地址的工作在指令执行时进行
同时设置一个重定位寄存器
真正访问地址 = 相对地址+重定位寄存器中地址
需要硬件地址变换机构支持
<img src="D:\操作系统\QQ截图20200427170142.png" style="zoom:50%;" />![](D:\操作系统\QQ截图20200427170204.png)

伙伴算法：
![](D:\操作系统\QQ截图20200429153514.png)

分配：分割大空间 空闲链表存在 直接分配 为空从大的空闲链表继续对半分出同时原链表改为空 分割后放入 位图改变

回收：位图改回 若同一大小的空闲链表不为空 则合并成大空间 递归直到为空 连接空闲链表

哈希算法：
对索引值进行建表 快速找到需要空闲分区 实现最佳分配策略

## 对换：



离散分配：
<img src="D:\操作系统\QQ截图20200429155808.png" style="zoom:67%;" />
（分散装入不相邻）

基本分页，基本分段，段页式管理

分页：定义（书）每个页从0开始编号 主存物理块（页框）大小和程序地址空间页面大小相同

**程序逻辑地址是由页号（页的多少）和业内地址（页面大小）组成**
以块为单位将作业若干页装入多个不相邻的内存块中 作业执行时根据逻辑地址中的页号找到块号 再确定当前指令要访问内存物理指令

页表（页面映像表）：记录进程页的地址 实现从页号到物理块号的物理映射



地址变换结构：
页表寄存器：也标注在内存中的始址

内存地址 = 物理块号x页大小+页内地址
得到数据需要访问两次内存 一次页表 一次访问数据地址

<img src="D:\操作系统\QQ截图20200429173100.png" style="zoom:80%;" />



分段：以段为单位分配内存 每段分配一个连续的主存空间 但各段之间不要求连续 每段大小不一样 分配的内存空间不一样

逻辑地址：段号+段内地址

段表：记录起始地址和长度

若作业某段信息找不到足够大的空间 可以使用紧凑
<img src="D:\操作系统\QQ截图20200429173752.png" style="zoom:67%;" />

​	

## 虚拟存储器

两大功能：请求调入功能和置换功能

从**逻辑上**对内存容量进行扩充
逻辑容量又内存容量和外存容量之和决定**（地址结构决定）**

速度接近内存 代价接近外存

缺页中断和中断不同
缺页中断发生在指令执行周期内
一次指令执行周期可能发生多次缺页中断

物理块分配：
<img src="D:\操作系统\QQ截图20200506164121.png" style="zoom:67%;" />

物理块分配算法：

1. 平均分配算法：（未充分考虑各进程各自独立的大小）
2. 按比例分配：
   ![](D:\操作系统\QQ截图20200506164524.png)
3. 优先权分配算法：高优先进程获得更多的物理块

页面调入过程：
<img src="D:\操作系统\QQ截图20200506165440.png" style="zoom:67%;" />

（置换算法必须选择恰当）

<img src="D:\操作系统\QQ截图20200506170012.png" style="zoom:67%;" />

![](D:\操作系统\QQ截图20200506174440.png)

1. 先通过页面大小得出分页的地址结构
2. 2362H 2为页号 362为页内地址 2不在快表中但先查询快表 查询内存找到并更新快表 最后访问内存得到数据
3. 1565H 1为页号 565为页内地址 1不在快表内 也不在内存中 形成缺页因为进程驻留集大小为2 所以需要置换页号 根据最近最久置换出0号页 存入缺页并更新 再通过页地址来调用内存获得数据
4. 25A5H 直接查询快表得到 再调用内存获取数据
5. 计算虚拟地址时 因为1号将0号页内存块进行替换 所以1号页框也为101H（同一内存块） 然后进行一般计算即可

# I/O设备：

分类：

数据速度：高速，中速，低速

信息交换单位：块设备，字符设备

设备共享属性：独占设备，共享设备，虚拟设备

操作特性：存储，输入输出

# 文件管理

文件：具有文件名的若干相关集合

有结构文件：
![](D:\操作系统\QQ截图20200518103912.png)

文件在逻辑上看是连续的 但是在物理设备上存放时有不同方式

物理存储：

连续分配：为每一个文件分配一组相邻的盘块
![](D:\操作系统\QQ截图20200518111423.png)

![](D:\操作系统\QQ截图20200518111908.png)

链接分配：将同属于分散的盘块链接成一个链表
![](D:\操作系统\QQ截图20200518112029.png)

显示链接与隐式链接：

隐式链接：指针在盘块中

显示链接：建立FCB和FAT来进行链接 FCB指出起始指针 FAT指出后继指针
![](D:\操作系统\QQ截图20200518112546.png)

（FAT存在内存中）
![](D:\操作系统\QQ截图20200518112631.png)

索引分配：给每个文件建立一个索引块 将盘块号（FAT）放在索引块内

缺点：
![](D:\操作系统\QQ截图20200518113958.png)

多级索引:
<img src="D:\操作系统\QQ截图20200518114101.png" style="zoom:80%;" />

<img src="D:\操作系统\QQ截图20200518114127.png" style="zoom:67%;" />

目录管理：
![](D:\操作系统\QQ截图20200518114711.png)

索引结点：减小文件目录项
![](D:\操作系统\QQ截图20200518114911.png)

存储空间管理：
<img src="D:\操作系统\QQ截图20200518115418.png" style="zoom:67%;" />

文件空间管理的**基本分配单位是盘块**

空间表法：
<img src="D:\操作系统\QQ截图20200518115826.png" style="zoom:67%;" />

建立空闲表 按起始盘块号递增排列

空闲链表法：

1. 空闲盘块链：
   <img src="D:\操作系统\QQ截图20200518120004.png" style="zoom:67%;" />
2. 空间盘区链：
   <img src="D:\操作系统\QQ截图20200518120049.png" style="zoom:67%;" />

位示图法：
<img src="D:\操作系统\QQ截图20200518120556.png" style="zoom:67%;" />

![](D:\操作系统\QQ截图20200518120706.png)

成组链接法（重点）：

空闲表和空闲链表的融合

<img src="D:\操作系统\QQ截图20200518121039.png" style="zoom:80%;" />

注意空间盘块栈顶指针位置 

空闲盘块获取 先将栈顶指针下移同时对栈空闲进行减一 当到达栈底时栈顶指针跳到下一个组 同时入下一组组栈（组有多个 但栈只有一个）